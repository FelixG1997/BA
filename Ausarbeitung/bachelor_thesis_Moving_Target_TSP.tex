\documentclass[english,version-2019-07]{uzl-thesis}


% Copy this file as a template for your thesis. You will have to take
% action at all places marked by
%
% !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
% !!! Your action is needed here !!!
% !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
%
% The first place your action is needed is the first line of this
% document:
%
%
% Language of the thesis:
%
% You must use either 'german' or 'english' above, depending on the
% language used in the main text. This will automatically setup a lot
% of things in the background.
%
%
% Version of the class:
%
% You must specify which version of the thesis class is to be
% used. This is important in case the class style changes in later
% years, but we still want an older thesis to look the same, even when
% things are changed in the class.
%
% Do not change or remove the version-xxxx key.
%
%
% Text encoding:
%
% Your thesis *must* be encoded in utf8 (unicode), which is the
% default in most editors these days. Do *not* change this to latin8.



%%%
%
% Main setup:
%
%%%
%
% You must use the \UzLThesisSetup command to specify numerous things
% about your thesis. This includes the entries on the title page, the 
% abstracts, and the bibliography style. You do so by specifying
% so-called "values" for so-called "keys". For instance, 
% for the key "Autor" you must provide your name as the value. You do
% so by writing 'Autor = {Max Mustermann}', that is, the value is put
% into curly braces. You can use the \UzLThesisSetup command
% repeatedly and the order in which you provide the keys is not
% important. 
%
% Everything shown on the title page must be in German -- even
% if the thesis is written in English! Just insert German text for
% German keys and English text for English keys (like 'Abstract' needs
% English text, while 'Zusammenfassung' needs German text).

\UzLThesisSetup{
  %
  % !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  % !!! Your action is needed here !!!
  % !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  %
  % First, specify the institut or clinic at which the thesis was
  % written. You get the logo file from them (make sure it has the
  % correct size, namely the same as the example). If they do not have
  % a logo, the university's default logo is used.
  %
  % The 'verfasst' gets two arguments. Change the first to {an der}
  % for clinics, as in 'Verfasst = {an der}{Medizinischen Klinik I}'
  %
  Logo-Dateiname        = {uzl-thesis-logo-itcs.pdf},
  Verfasst              = {am}{Institut für Theoretische Informatik},
  %
  % The titles:
  %
  Titel auf Deutsch     = {
    Algorithmen für bewegende Ziele in TSP
  }, 
  Titel auf Englisch    = {
    Algorithms for Moving-Target TSP
  },
  %
  % Author and supervisor:
  % 
  % Note that the 'Betreuer' or 'Betreuerin' is the supervisor, that
  % is, the professor who officially supervises the thesis. If there
  % is also an assistent of the professor who helped (typically a
  % lot), use 'Mit Unterstützung von' to thank that person. If the
  % thesis was mainly written 'externally' at some company or another
  % institute, point this out using 'Weitere Unterstützung'. 
  % 
  % For your own name, do *not* add things like "BSc" or "BSc
  % cand.". For the supervisor, you should normally include
  % "Prof. Dr." or "PD Dr." (ask your supervisor, what is
  % appropriate), but nothing more (so no
  % "Univ.-Prof. Dr. Dr. h.c. mult." unless your supervisor insists).  
  %
  Autor                 = {Felix Greuling},
  Betreuerin            = {Prof. Dr. Maciej Liskiewicz},
  % 
  % Optional: Supporting persons and institutions. The text should be
  % in German, even for an English thesis.
  %
  %Mit Unterstützung von = {Harry Hilfreich},
  % 
  %   Weitere Unterstützung = {
  %     Die Arbeit ist im Rahmen einer Tätigkeit bei der Firma Muster GmbH
  %     entstanden.
  %   },
  %
  %
  % Your Degree Programm (Studiengang)
  %
  % Specify 'Bachelorarbeit' or 'Masterarbeit' and the degree
  % programme. Make sure the name of programme is correct and not
  % some abbreviation or some incorrect variant. For instance:
  % 'Medizinische Ingenierwissenschaft', but not 'MIW';
  % 'Medizinische Informatik', but not 'Medizin-Informatik';
  % 'Informatik', but not 'Informatik (SSE)'.
  %
  % Use German names for German programmes and English names for
  % English ones, so 'Infection Biology', not 'Infektionsbiologie'. 
  % For programmes that have a German bachelor and an English master,
  % use the German name for a bachelor thesis and the English name for
  % the master thesis.
  %
  Bachelorarbeit,
  Studiengang           = {Informatik},
  %
  % Date on which the thesis is turned in:
  %
  Datum                 = {28. November 2019},
  %
  % The English abstract. You must always provide abstracts in German
  % and in English. 
  %
  Abstract              = {
    \textcolor{red}{TODO}
  },
  Zusammenfassung       = {
    \textcolor{red}{TODO}  
  },
  %
  % Optional: 'Danksagungen' (German) or 'Acknowledgements'
  % (English). Both keys are optional and both have the same effect of
  % adding an acknowledgements text after the abstracts and before the
  % table of contents.
  %
  Acknowledgements      = {
    \textcolor{red}{TODO}
  },
  % Bibliography style: Choose between
  % 
  % 'Alphabetische Bibliographie'
  % for all degree programmes in the natural sciences 
  % 
  % 'Numerische Bibliographie'
  % alternative for all other degree programmes
  % 
  % Either will load biblatex and setup the citation methods and the
  % bibliography styles correctly. You should not mess with them.
  % 
  % Alphabetische Bibliographie
  % Alternatively:
   Numerische Bibliographie
}


\UzLStyle{alegrya modern design}
%
% A design that uses the sans serif version of the Alegrya font for
% the headlines. This is a nice modern overall design.
%
%%%




%%%%%%%%
%
% Now, include the package you need here using \usepackage. 
%
% However, many standard packages are already loaded by the class:
%
% amsmath, amssymb, amsthm, babel, biblatex, csquotes, etoolbox,
% filecontents, fontspec, geometry, hyperref, tikz (with libraries
% arrows.meta, positioning and shapes), varioref, url 
%
% Indeed, in many cases you will not need any extra packages.
%
%%%%%%%


\begin{document}

%
% The title page and table of contents will be inserted automatically
% here. 
%



\chapter{Introduction}
% In a German thesis write: \chapter{Einleitung}



% !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
% !!! Your action is needed here !!!
% !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
%
% Replace with your own introduction:
\lstMakeShortInline[style=code,style=inline,language={[LaTeX]tex},moretexcs={chapter}]|
 


\section{Contributions of this Thesis}
% In a German thesis write: \section{Beiträge dieser Arbeit}

% !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
% !!! Your action is needed here !!!
% !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
%
% Replace with a detailed account of your contributions:
\textcolor{red}{TODO}


\section{Related Work}
% In a German thesis write: \section{Verwandte Arbeiten}

% !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
% !!! Your action is needed here !!!
% !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
%
% Replace with a detailed account of what other people have already
% researched concerning your thesis's theme. Even when (indeed,
% especially when) there has been only little or even no research by
% other people, you should explain in detail that this is the case and
% why it is the case. 

% write about Helvig, Moraes
\textcolor{red}{TODO}

\section{Structure of this Thesis}
% In a German thesis write: \section{Aufbau dieser Arbeit}


% !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
% !!! Your action is needed here !!!
% !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
%
% Replace the following by one or two paragraphs describing the
% thesis's structure.

\textcolor{red}{TODO}




% !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
% !!! Your action is needed here !!!
% !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
%
% Replace the whole text chapter with the main text of your thesis! 

\chapter{The moving-target traveling salesman problem in general}
\section{Definitions}
In MT-TSP we consider an amount of targets $T=\{t_1,...,t_n\}$ and a set of velocities $V=\{v_1,...,v_n\}$ so that each moving with a constant movement speed $\overrightarrow{v_i}$. A pursuer starts at the origin $O$ (a defined position), moving with a velocity of $v_p$. His aim is to visit all targets once and finishes with returning to the origin.

Therefore, we can model this problem as the following graph \\
$G=(T, V, O, v_p)$. 

%------------------------------------------------------------------------------------------
\section{Instances of Moving-Target TSP}

It was proven that MT-TSP is NP-hard. Some instances can result in an unbounded error, whenever the pursuer choses a non-optimal tour. Therefore, the condition $v_p > |\overrightarrow{v_i}|$ must apply, to avoid these errors. This was proven by the authors in \cite{helvig}, since the goal is the most fast optimal tour.  Thus, instead of directly calculating the tour of the pursuer, it is necessary to determine the solvability of the input. Whenever it is not possible we gain a 'No'-instance, otherwise we go ahead and calculate the tour. \\
This paper presents two concrete cases:
\begin{itemize}
\item[1)]
1D-case: 
Each target's movement is limited to a single line 

\item[2)]
2D-case:
The movement direction of a target consists of a two-dimensional vector 

\end{itemize}

Each case is investigated for the shortest and the fastest tour. Helvig , Robins and Zelikovsky presented in \cite{helvig} the first heuristics in the field of MT-TSP. However, determining the approximation for general cases is hard, because there are many influences that determine the complexity of the problem. The approximation research in \cite{hammar} showed that MT-TSP cannot be approximated better than by a factor of $2^{\pi (\sqrt{n})}$ by a polynomial time algorithm unless P=NP.

Later on, we will compare new heuristics and algorithms with those that recently proposed in \cite{moraes}. This paper examines Genetic Algorithm, Simulated Annealing and Ant Colony Optimization to solve MT-TSP.


%------------------------------------------------------------------------------------------
\subsection{One-dimensional-case}

This specific case is already introduced extensive in \cite{helvig}. Each movement is fixed on a single line, thus, there are two possible directions for a target and the pursuer. 


%Furthermore, the case of the shortest tour is introduced, which was not examined in the work of %Helvig, Robins and Zelikovsky.

%------------------------------------------------------------------------------------------
\subsection{Two-dimensional-case}

In this case another dimension is added. We will consider different scenarios with fixed numbers of targets and corridors. Compared to the 1D-case, in which a target is fixed on a line, targets freely move within the space. Therefore, we define corridors, representing the number of vectors in which the targets move, resulting in different complexities.

This paper focusses on the 2D-case. Previous works did not construct concrete heuristics for this type of case, therefore, this paper shows new aspects in the field of MT-TSP.

%------------------------------------------------------------------------------------------
\subsection{Input \& Output}
To set up heuristics a suitable input and output are necessary. Thus, the MT-TSP can be modelled as graph problem (refering section 2), further heuristics just expect a graph $G$ as parameter. 

The Output, on the other hand, can look very different. The most obvious parameter are the length and the time needed to finish the tour. Whenever, there is no possible tour, an MT-TSP algorithm needs to return a 'No'-instance. 

Furthermore, a tour should be comprehensible. Therefore, the targets are displayed in the order in that the pursuer executes the tour. For each target the initial coordinates and the time and the position whenever the pursuer intercepts the target are monitored. To fully understand and analyse the tour a visualization is a good application, but not necessary. 

%------------------------------------------------------------------------------------------
\chapter{Moving-Target TSP in one dimension}%: Document Setup and Document Structure}
\label{chapter-use}

This specific instance was introduced in \cite{helvig}. Each target and the pursuer are restricted to a single line, so there are only two possible directions of movement. The first naive approach is to calculate the cost of the tour to intercept all the targets on the right side of the origin and then on the left and vice versa. Choose the tour with lower costs. This will probably result in an unbounded error with simple counter examples (\textcolor{red}{TODO}: create a graphic with a counter example), where the pursuer probably takes and eternity to intercept a target.

Therefore, the pursuer is only allowed to change his direction, whenever he intercepts the fastest target either on the left or right side of the origin. These targets are named as turning points. Turning points that are not the fastest target can not reduce the tour time. This time not used to catch up with the fastest target is equivalent to waiting at one point. As already mentioned (\textcolor{red}{TODO}), waiting at one point results in not optimal tours. 

With this knowledge about turning points, the term \emph{state} is introduced. A state is a snapshot of a tour. It represents a potential turning point at which the pursuer then attempts to reach either the next fastest target on the same or the other side of the origin. It required two targets to define a state. First, the target, where the pursuer is currently located ($s_k$), and second, the fastest target ($s_f$) on the other side of the origin. Thus, a state can be described as the a tuple ($s_k, s_f$). As special cases, there are the states $A_0$ and $A_{final}$. Neither $A_0$ or $A_{final}$ have such a tuple ($s_k, s_f$), these states just define the start and end of each tour. For each state $A_i$, the shortest time to reach the state can be calculated with the time function $t$. It applies $t(A_0) = 0$.

In order to determine all states, it is necessary to divide the targets into the lists \emph{Left} and \emph{Right}. Each target, which is located on the left of the origin, is inserted \emph{Left}. Analogous for the list \emph{Right}. Now the targets are sorted by the speed leading away from the origin in descending order. Targets that are closer to the origin and additionally slower than others are removed in the respective lists. Thereby, just the potential turning points are remaining. In order to determine the list of all states, named \emph{States}, all combinations of the lists \emph{Left} and \emph{Right} and vice versa are inserted for $s_k$ and $s_f$. The list is now sorted in ascending order of the sum of the indices of the targets from the lists \emph{Left} and \emph{Right}. Therefore, the combinations of the fastest targets are in front of \emph{States}. 

In a state A, there are two options: Either the fastest target on the left or on the right side of the pursuer (also from the perspective of the origin!) is intercepted next. These targets in turn are potential turning points, i.e. a \emph{transition} into the next state B is generated. The notion of a transition between the states A and B is $A\rightarrow B$. A transition applies to the respective time $t[A]$. Therefore, the position of the target $s_k$ of each $A$ and $B$ must be updated with $s_k'= s_k + v_{s_k} \cdot t[A]$. With simple physics equations the time to reach $B$ can be calculated with $t = \dfrac{s_{k_{B}}' - s_{k_{A}}'}{v_{pursuer} - v_{B}}$. Thus, the pursuer always travels with maximum speed, this equation uses $v_{pursuer}$ instead of $v_{A}$. This time represents the weight of the transition. Summarized the transition $A\rightarrow B$ depends on the timestamp of $A$ and the transition weight varies over time. 

With the options to move to the left or right turning point, there are two transitions outgoing the current state: $\tau_{left}$ and $\tau_{right}$. Thus, each state has up to two transitions into other states. As soon as each turning point is intercepted on the left side of the origin, there is only the transition $\tau_{right}$ into the final state, which is then named as $\tau_{final}$. The weight of the edge is then determined by time needed to intercept all remaining targets on the other side. The final state has no transitions into other states. With $t[\tau_{left}]$ or $t[\tau_{right}]$ the time is calculated to intercept the fastest target on the left or right side from the considered $s_k$ in state $A$ at time $t(A)$.

Now the problem with states and transitions between them can be transformed into a graph problem. The states represent the vertices $V$ and the transitions are the edges $E$ between the vertices. Thus, the Graph $G$ can be modelled as $G=(V,E)$. Next the exact structure of $G$ needs to be specified. First, the start state $A_0$ is inserted. As previously mentioned, \emph{States} is generated in ascending order of the sum of the indices in the lists \emph{Left} and \emph{Right}. Now the states with the lowest sum value are placed next to $A_0$. Next, the same thing is done with the next higher sum value with its states placed next to the states of the underlying sum value. Proceed with this process for all other states until the end of the list and append $A_{final}$ at the end. Transitions can only lead to states of higher sum values. Therefore, the graph is acyclic, as there are no edges into the current or previous vertices. Caused by some transitions immediately into $A_{final}$, there are probably vertices to which no edge is drawn.

The new graph problem can thus be solved as a shortest path problem by finding the shortest way from $A_0$ to $A_{final}$. Since the graph is acyclic, a simple procedure can be chosen. 

\section{Algorithm by Helvig, Robins and Zelikovsky}

With this requirements the authors of \cite{helvig} showed an exact $\mathcal{O}(n^2)$-time algorithm for 1D-cases, which is based on dynamic programming. The goal is to receive the fastest, optimal tour, intercepting each target. 

First the algorithm generates the lists \emph{Left}, \emph{Right} and \emph{States} as described above. 
Next, iterate through the state list in topological order. To make it easier to understand, modelling as a graph makes sense. The algorithm solves this rather \emph{on-the-fly} than generating each transition between the states. This method is possible through the topological order which is gained by the special sorting and eliminations of \emph{Left} and \emph{Right} and further the sorting of \emph{States}. Furthermore, by far not not all transitions are considered. Some states get skipped or directly lead into $A_{final}$, caused by performing one of the following steps, while iterating through each state $A_i$:

\begin{itemize}
\item
If $A_i$ has no transitions into it, proceed with the next state. This case can be recognized whenever the time function array at index $i$ is still initialized with $t[i] = \infty$. 
\item
If the pursuer has intercepted each target on one side, create a transition from $A_i$ into
the final state $A_{final}$. Note, to calculate the transition weight, determine the maximum time from $A_i$ to each extant target on the other side of the origin.
\item
Otherwise calculate the transitions $\tau_{left}$ and $\tau_{right}$, which correspond to sending the pursuer after either the fastest target on the left or the fastest target on the right. If $t[A_i]$ added with the time needed to perform the transition is faster than possibly before with other states, update $t[A_i]$ with this result.
\end{itemize}

Therefore, the time used to reach a state $B_i$ with the shortest sequence of states is defined by $t(A_i)=min\{t(A)+t(\tau)\vert\tau:A\rightarrow B\}$. Then traverse backwards from $A_{final}$ to $A_0$, which denotes the reversed list of turning points. Last calculate which targets are intercepted between the state pair, so we can describe an optimal tour of targets. Iterating the states squares the runtime, which requires the algorithm to run exactly in $\mathcal{O}(n^2)$.


\chapter{Conclusion}
% In a German thesis write: \subsection{Zusammenfassung und Ausblick}


% !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
% !!! Your action is needed here !!!
% !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
%
% Replace the following with your conclusion

\textcolor{red}{TODO}



% !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
% !!! Your action is needed here !!!
% !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
%
% Replace following example entries with the ones of your thesis.

\begin{bibtex-entries}

@article{helvig,
  title={The moving-target traveling salesman problem},
  author={Helvig, Christopher S and Robins, Gabriel and Zelikovsky, Alex},
  journal={Journal of Algorithms},
  volume={49},
  number={1},
  pages={153--174},
  year={2003},
  publisher={Elsevier}
}

@article{moraes,
  title={Experimental Analysis of Heuristic Solutions for the Moving Target Traveling Salesman Problem Applied to a Moving Targets Monitoring System},
  author={de Moraes, Rodrigo S and de Freitas, Edison P},
  journal={Expert Systems with Applications},
  year={2019},
  publisher={Elsevier}
}

@inproceedings{hammar,
  title={Approximation results for kinetic variants of TSP},
  author={Hammar, Mikael and Nilsson, Bengt J},
  booktitle={International Colloquium on Automata, Languages, and Programming},
  pages={392--401},
  year={1999},
  organization={Springer}
}


\end{bibtex-entries}
\end{document}